;(a)
;上記式では、二項演算の演算子を型とみなして演算子のパッケージに微分関数derivを定義した。
;number? variable?の述語は単項演算であるため上記の二項演算パッケージには含められない。
;
;(b)
; ３章まで読み進めて理解が深まったら、put-get.scmを置き換える
; via. http://sicp.naochan.com/memo.pl?p=put-get-gen
(load "./put-get.scm")
;ここから解答
(define (install-add-deriv-package)
	(define (sum-deriv exp var)
		(make-sum (deriv (addend exp) var)
			  (deriv (augend exp) var)))
	(define (make-sum a1 a2)
		(cond ((=number? a1 0) a2)
			  ((=number? a2 0) a1)
			  ((and (number? a1) (number? a2) (+ a1 a2)))
			  (else (list '+ a1 a2))))
	(define (addend s) (car s))
	(define (augend s)
		(if (null? (cddr s))
			(cadr s)
			(cons '+ (cdr s))))

	(put 'make '+ make-sum)
	(put 'deriv '+ sum-deriv))
(define (install-mul-deriv-package)
	(define (product-deriv exp var)
		((get 'make '+)
			(make-product (multiplier exp)
						  (deriv (multiplicand exp) var))
			(make-product (deriv (multiplier exp) var)
						  (multiplicand exp))))
	(define (multiplier p) (car p))
	(define (multiplicand p)
		(if (null? (cddr p))
			(cadr p)
			(cons '* (cdr p))))

	(define (make-product m1 m2)
		(cond ((or (=number? m1 0) (=number? m2 0)) 0)
			  ((=number? m1 1) m2)
			  ((=number? m2 1) m1)
			  ((and (number? m1) (number? m2)) (* m1 m2))
			  (else (list '* m1 m2))))
	(put 'make '* make-product)
	(put 'deriv '* product-deriv))

;(c)
;2.56の解答をほぼそのままコピー
;base、exponentの実装を変更(cadr => car, caddr => cadr)
;exp-derivのmake-productの部分をgenericな呼び出しに変更
(define (install-exp-deriv-package)
	(define (exp-deriv exp var)
		(let ((product-proc (get 'make '*)))
			(product-proc
				(product-proc (exponent exp)
			 			      (make-exponentiation (base exp) (- (exponent exp) 1)))
				(deriv (base exp) var))))
	(define (exponentiation? x)
		(and (pair? x) (eq? (car x) '**)))
	(define (base x)
		(car x))
	(define (exponent x)
		(cadr x))
	(define (make-exponentiation base exponent)
		(cond ((=number? exponent 0) 1)
			  ((=number? exponent 1) base)
			  (else (list '** base exponent))))
	(put 'make '** make-exponentiation)
	(put 'deriv '** exp-deriv))

;(d)
;各パッケージのputの引数を入れ替えれば問題なし
;ex. (put 'make '** make-exponentiation) => (put '** 'make make-exponentiation)

; generic-deriv
(define (deriv exp var)
	(cond ((number? exp) 0)
		  ((variable? exp) (if (same-variable? exp var) 1 0))
		  (else ((get 'deriv (operator exp)) (operands exp)
		  									 var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (=number? exp num)
	(and (number? exp) (= exp num)))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
	(and (variable? v1) (variable? v2) (eq? v1 v2)))

; test
(define put-get (put-get-gen))
(define put (car put-get))
(define get (cadr put-get))
(install-add-deriv-package)
(install-mul-deriv-package)
(install-exp-deriv-package)
(display (deriv '(+ x 3) 'x))
(newline)
(display (deriv '(* x 2) 'x))
(newline)
(display (deriv '(** x 2) 'x))
(newline)
